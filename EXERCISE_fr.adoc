= Application web simple avec Spring
:tip-caption: üí°
:note-caption: ‚ÑπÔ∏è
:warning-caption: ‚ö†Ô∏è
:icons: font
:hardbreaks-option:

Pr√©fix√© par ‚úîÔ∏è, des "checkpoints" pour vous aider √† v√©rifier que vous avez tout bon.

L‚Äôobjectif de cet exercice est de construire une application web minimaliste (TODO list), utilisant *spring-mvc* pour la partie HTTP et *spring-data-jdbc* pour la partie persistance des donn√©es.

== Pr√©requis

* Git
* Java 21
* Maven 3.9.x
* Docker
* Docker compose v2
* (Optionnel, mais fortement recommand√©) IntelliJ edition _community_ 2024

'''

* Sur la page du template https://github.com/lernejo/maven-starter-template, cliquer sur "Use this template"
* ‚ö†Ô∏è Renseigner comme nom de d√©p√¥t : *web_app_spring_training*
* Marquer le futur d√©p√¥t comme *private*
* Une fois le d√©p√¥t cr√©√©, installer l'app https://github.com/apps/korekto[Korekto], ou mettre √† jour sa configuration afin qu'elle ait acc√®s √† ce nouveau d√©p√¥t
* Cloner le d√©p√¥t en utilisant l'*url SSH*
* La branche par d√©faut est la branche `main`, vous √™tes libre de faire des https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request[Pull Requests], mais seule la branche `main` sera corrig√©e.

== Partie 1 - BOM & D√©pendances

[NOTE]
====
On appelle BOM (**B**ill **O**f **M**aterials), une liste de librairies et frameworks dont les versions sont garanties compatibles.

En effet, l‚Äô√©cosyst√®me Java √©volue tr√®s vite, et des changements incompatibles (m√©thodes ou classes qui disparaissent, etc.) arrivent fr√©quemment.

Ainsi les plus gros frameworks (comme Spring-Boot) publient des BOM pour assurer que tous les binaires en d√©pendance d‚Äôun projet fonctionnent bien les uns avec les autres
====

* Dans le fichier *pom.xml*, ajouter le BOM de Spring-Boot dans la section `<dependencyManagement>`

[source,xml]
----
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>3.4.0</version>
            <scope>import</scope>
            <type>pom</type>
        </dependency>
    </dependencies>
</dependencyManagement>
----

* Ajouter la d√©pendance qui nous int√©resse dans la section `<dependencies>`

[source,xml]
----
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <!--1-->
    </dependency>
</dependencies>
----

<1> La version n‚Äôest pas pr√©cis√©e car elle est g√©r√©e par le BOM

== Partie 2 - Endpoints HTTP

Nous allons coder deux endpoints HTTP qui permettrons de

* Consulter une liste de note
* Ajouter une note

L‚Äô√©tat dans un premier temps sera g√©r√© en m√©moire gr√¢ce √† une `java.util.ArrayList`.

Spring-mvc fourni un certain nombre d‚Äôannotations pour indiquer au framework le r√¥le des classes ou des m√©thodes.
Dans notre cas, ce qui nous int√©resse c‚Äôest :

* `@RestController` : marque une classe comme √©tant un contr√¥leur (adaptateur HTTP)
* `@GetMapping` : marque une m√©thode comme g√©rant une requ√™te HTTP *GET*
* `@PostMapping` : marque une m√©thode comme g√©rant une requ√™te HTTP *POST*
* `@RequestBody` : marque un param√®tre de m√©thode indiquant au framework d‚Äôy injecter le corps d‚Äôune requ√™te HTTP, en le d√©s√©rialisant (transformation du texte JSON en objet Java)

* Cr√©er un record `fr.lernejo.todo.Todo` avec deux param√®tres `message` et `author`
* Cr√©er une classe `fr.lernejo.todo.TodoListController`
* Ajouter deux m√©thodes, une pour ajouter un `Todo` dans la liste, une autre qui renverra cette liste
* Annoter ces m√©thodes de fa√ßon √† ce qu‚Äôelle r√©ponde sur les requ√™tes HTTP suivantes :
** *POST* /api/todo
** *GET* /api/todo
* Cr√©er une classe `fr.lernejo.todo.TodoListApp` annot√©e avec `@SpringBootApplication`
* Y ajouter une fonction `main` avec le contenu suivant : `SpringApplication.run(TodoListApp.class, args);`
* Lancer l‚Äôapplication gr√¢ce √† la m√©thode `main`, par d√©faut le serveur lanc√© par le framework √©coute sur le port 8080
* V√©rifier que les endpoints HTTP fonctionnent comme attendu avec un client HTTP (navigateur, curl, etc.)
* Indexer et commiter les fichiers nouvellement cr√©√©s

== Partie 3 - Filtre pour ajouter un header HTTP

Pour identifier les diff√©rentes instances si notre application est dimensionn√©e horizontalement, nous allons cr√©er un filtre qui ajoutera un header *Instance-Id* √† chaque r√©ponse HTTP.

[NOTE]
====
Un filtre est un composant impl√©mentant l‚Äôinterface `jakarta.servlet.Filter`, qui sera sollicit√© √† l‚Äôarriv√©e d‚Äôune nouvelle requ√™te.

Impl√©mentant le pattern *cha√Æne de responsabilit√©* le r√¥le d‚Äôun filtre (un maillon de la cha√Æne) est de faire une op√©ration et de [.underline]#passer la main au filtre d‚Äôapr√®s# :

[source,java]
----
chain.doFilter(request, response);
----

Un filtre peut √©galement d√©cider d‚Äôinterrompre la cha√Æne, auquel cas la r√©ponse HTTP sera renvoy√©e telle quelle.
====

* Cr√©er une classe `fr.lernejo.todo.ApplicationIdentifierFilter` impl√©mentant l‚Äôinterface `jakarta.servlet.Filter` et annot√©e avec `@Component`
* G√©n√©rer un `UUID` al√©atoire dans le constructeur de cette classe, et stocker sa conversion en `String` dans un champ de la classe
* Dans l‚Äôimpl√©mentation de la m√©thode `doFilter` ajouter le header *Instance-Id* avec cette valeur √† la r√©ponse avant d‚Äôappeler le maillon suivant de la cha√Æne de responsabilit√©.
Pour cela, la r√©ponse doit √™tre _match√©e_ vers le type `jakarta.servlet.http.HttpServletResponse` qui lui poss√®de une m√©thode `setHeader`

[NOTE]
====
Le pattern-matching est un outil qui permet de distinguer des branches d'ex√©cutions en fonction d'un type, ou m√™me de son contenu.

En Java, le pattern matching est en construction.

Mais on peut d√©j√† l'utiliser pour cr√©er une variable du bon type sans _downcast_.

[source,java]
----
public void myMethod(Object myParam) {
    if (myParam instanceof String myString) {
        // <1>
    }
}
----
<1> Ici la variable `myString` de type String est disponible. On ne rentrera pas dans le `if` si le param√®tre donn√© n'est pas un `String`
====


* D√©marrer l‚Äôapplication et v√©rifier la pr√©sence du header *Instance-Id* dans un appel au endpoint *GET*
* Plusieurs appels retournerons m√™me header, cependant si l‚Äôapplication red√©marre, celui-ci changera
* Indexer et commiter les fichiers nouvellement cr√©√©s

== Partie 4 - Image Docker de notre application et Docker Compose

Docker est un outil permettant de lancer des conteneurs reposant sur des images.
Les images elles-m√™mes sont des archives contenant les binaires n√©cessaires/voulus (os, tools, app, etc.)

Docker Compose est un ordonnanceur de conteneur, l‚Äôid√©e est de pouvoir piloter depuis un m√™me fichier descripteur un ensemble de conteneur de mani√®re coh√©rente.

* Ajouter dans la section `<build>` du fichier *pom.xml* le contenu suivant

[source,xml]
----
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <version>3.4.0</version>
            <executions>
                <execution>
                    <goals>
                        <goal>repackage</goal> <!--1-->
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
----

<1> Le goal *repackage* de ce plugin fourni par Spring-Boot va remplacer le jar cr√©√© par le *maven-jar-plugin* par un jar auto-ex√©cutable contenant √©galement le code des d√©pendances

// -

* Cr√©er un fichier *Dockerfile* √† la racine du projet (√† c√¥t√© du fichier *pom.xml*)
* Y copier le contenu suivant

[source,Docker]
----
# <1>
FROM maven:3.9.9 AS build
COPY src /home/app/src
COPY pom.xml /home/app
# <2>
RUN mvn -f /home/app/pom.xml clean package

# <3>
FROM eclipse-temurin:21-jdk
# <4>
COPY --from=build /home/app/target/maven_training-1.0.0-SNAPSHOT.jar /usr/local/lib/app.jar
# <5>
EXPOSE 8080
ENTRYPOINT ["java","-jar","/usr/local/lib/app.jar"]
----

<1> Image contenant Maven utilis√©e pour construire le projet dans une √©tape "*build*"
<2> Lancement de la construction du projet
<3> Image de base utilis√©e pour l‚Äôimage finale, Maven n‚Äôy est pas
<4> Il peut √™tre n√©cessaire de changer le nom de l‚Äôarchive construite si le nom ou la version du projet a √©t√© chang√©e
<5> L‚Äôapplication √©coute sur le port 8080, ce que nous indiquons comme param√®tre de l‚Äôimage finale pour pouvoir g√©rer les redirections de port et la configuration r√©seau par la suite

// -

* Cr√©er un fichier *docker-compose.yml* √† la racine du projet
* Y copier le contenu suivant

[source,yml]
----
services:
  todolist:
    build : . # <1>
    ports:
      - 8081:8080 # <2>
----

<1> Utilise le fichier *Dockerfile* dans le m√™me r√©pertoire
<2> Redirige le port 8081 de la machine h√¥te (gauche) vers le port 8080 du container (droite)

// -

* D√©marrer l‚Äôapplication avec la commande `docker compose up`
* ‚úîÔ∏è V√©rifier que le service est bien disponible (GET http://localhost:8081/api/todo)
* Indexer et commiter les fichiers nouvellement cr√©√©s

== Partie 5 - Dimensionnement et r√©partition de la charge

Nous allons maintenant mettre en place un load-balancer pour r√©partir le traffic HTTP sur plusieurs instances de notre application.

* Ajouter dans le fichier *docker-compose.yml* le contenu suivant sous *services*

[source,yml]
----
traefik:
    image: traefik:2.5
    restart: unless-stopped
    ports:
      - 80:80
      - 8080:8080
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./traefik.toml:/traefik.toml
----

* Cr√©er un fichier *traefik.toml* √† la racine du projet avec le contenu suivant :

[source,toml]
----
[global]
  sendAnonymousUsage = false

[accessLog]

[log]
  level = "DEBUG"
  format = "common"

[providers]
  [providers.docker]
    endpoint = "unix:///var/run/docker.sock"
    watch = true
    exposedByDefault = true
    swarmMode = false

[api]
  dashboard = true
  debug = false
  insecure = true

[entryPoints]
  [entryPoints.insecure]
    address = ":80"
----

[NOTE]
====
Traefik poss√®de un dashboard qui est consultable √† l‚Äôurl http://localhost:8080.
Le port *8080* est utilis√© pour l‚Äôadministration alors que le port *80* est utilis√© pour le service.
Quand Traefik utilise le _provider_ Docker, la configuration du routage est d√©duite des labels renseign√©s sur chaque service Docker Compose.
====

* Ajouter les labels suivants au service *todolist* dans le fichier *docker-compose.yml* :

[source,yml]
----
labels:
- "traefik.http.routers.todolist.rule=PathPrefix(`/app`)"
- "traefik.http.middlewares.todolist.stripPrefix.prefixes=/app"
- "traefik.http.routers.todolist.middlewares=todolist@docker"
----

* Lancer les diff√©rents containers gr√¢ce √† la commande `docker compose up`
* ‚úîÔ∏è V√©rifier que le service est rendu derri√®re l‚Äôurl http://localhost:80/app/api/todo
* Supprimer le port de machine h√¥te sp√©cifi√© dans la configuration du service *todolist* dans le fichier *docker-compose.yml*

[NOTE]
====
Un port ne peut pas √™tre √©cout√© par plus d‚Äôun process.
Si un port de la machine h√¥te est fix√© dans la configuration d‚Äôun service Docker Compose, celui-ci ne peut pas √™tre dimensionn√© avec la fonctionnalit√© replica
====

* Ajouter la configuration suivante √† ce m√™me service pour qu‚Äôil y en ait 3 instances

[source,yml]
----
deploy:
  replicas: 3
----

* Lancer les diff√©rents containers gr√¢ce √† la commande `docker compose up`
* ‚úîÔ∏è V√©rifier que le header *Instance-Id* a 3 valeurs distinctes quelque-soit le nombre d‚Äôappels HTTP qui sont fait
* Indexer et commiter les changements

== Partie 6 - Persistence en base de donn√©es

Pour l‚Äôinstant l‚Äô√©tat de notre application est g√©r√© dans la m√©moire de notre application, et par cons√©quence dans des m√©moires diff√©rentes en fonction de l‚Äôinstance sur laquelle un appel HTTP est redirig√©.

Le comportement du point de vue de l‚Äôutilisateur est per√ßu comme incoh√©rent.

En effet, ce genre d‚Äôapplication dite _stateful_ (car ayant un √©tat) n‚Äôest pas compatible avec le dimensionnement horizontal.

On va dans ce cas s‚Äôorienter vers une application _stateless_ (car n‚Äôayant pas d‚Äô√©tat) et g√©rer l‚Äô√©tat ailleurs.

Il existe pl√©thore de solutions pour partager de l‚Äô√©tat entre des instances distinctes (brokers, cache, base de donn√©es, m√©moire partag√©e type Hazelcast, etc.)

Dans cet exercice, nous allons stocker l‚Äô√©tat dans une base PostgreSQL.

* Ajouter dans le fichier pom.xml les d√©pendances suivantes

[source,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
</dependency>
----

* Cr√©er un fichier *application.yml* dans le r√©pertoire *src/main/resources* avec le contenu :

[source,yml]
----
spring:
  sql.init.mode: always # <1>
  datasource:
    url: jdbc:postgresql://localhost:5432,postgres:5432/postgres
    username: postgres
    password: example
----
<1> Configuration qui permet d‚Äôex√©cuter le fichier *schema.sql* au d√©marrage de l‚Äôapplication

* Cr√©er √† c√¥t√© un fichier *schema.sql* avec le contenu :

[source,sql]
----
CREATE TABLE IF NOT EXISTS todo (
    id BIGSERIAL PRIMARY KEY,
    message TEXT,
    author CHAR(64)
);
----

* Cr√©er une classe `fr.lernejo.todo.TodoEntity` annot√©e avec `@Table("todo")`
* Ajouter 3 champs _publics_ _mutables_
** `Long id` annot√© avec `@Id`
** `String message`
** `String author`

[NOTE]
====
Les outils de persistance actuels (Spring-data, Hibernate, etc.) fonctionnent sur la base d‚Äô_entit√©s_ qui repr√©sente au format objet les donn√©es en base.

Les entit√©s (par extension, JPA) sont attendues comme √©tant des objets r√©pondant √† certains crit√®res, notamment celui d‚Äô√™tre _mutable_.
====

* Cr√©er une interface `fr.lernejo.todo.TodoRepository` annot√©e avec `@Repository` et √©tendant `CrudRepository<TodoEntity, Long>`

[NOTE]
====
Ici la _magie_ de Spring va op√©rer, l‚Äôinterface aura une impl√©mentation au runtime (pas de classe concr√®te donc) par l‚Äôinterm√©diaire d‚Äôun proxy dynamique.

Ainsi toutes les m√©thodes de cette interface qui permettent des op√©rations standards comme sauvegarder, supprimer, lister, trouver par id, etc. auront un comportement (standard) sans qu‚Äôil soit besoin de le coder.

C‚Äôest l‚Äôimpl√©mentation la plus avanc√©e du pattern *Generic DAO*.
====

* Modifier la classe `TodoListController` pour :
** Prendre comme param√®tre de constructeur un objet de type `TodoRepository`
** Utiliser ce repository dans les m√©thodes en remplacement de l‚Äô`ArrayList`
** Supprimer le champ de type `ArrayList` devenu inutile

* Modifier le fichier `docker-compose.yml` en y ajoutant le service suivant

[source,yml]
----
postgres:
    image: postgres:14.0-alpine
    container_name: postgres
    ports:
      - 5432:5432
    environment:
      POSTGRES_PASSWORD: example
----

* Relancer la construction de l‚Äôimage docker avec la commande `docker compose build`
* Lancer les diff√©rents containers avec la commande `docker compose up`
* ‚úîÔ∏è V√©rifier la coh√©rence de comportement dans l‚ÄôAPI malgr√© l‚Äôutilisation d‚Äôinstances diff√©rentes √† travers l‚Äôurl http://localhost:80/app/api/todo
* Indexer et commiter les changements

Un petit schema de l‚Äôarchitecture du projet que vous venez de r√©aliser pour finir :

image::final_architecture.png[align=center]
